?rstiefel
library(rstiefel)
library(mvnorm)
library(mrvnorm)
library(mvrnorm)
install.packages('mvrnorm')
install.packages('mvrnorm')
install.package('mvrnorm')
install.packages('mvrnorm')
install.packages('mvtnorm')
library(mvtnorm)
?mvtnorm
?rmvnorm
X <- rmvnorm(N, mean=rep(0, N), sigma=A)
N = 100
X <- rmvnorm(N, mean=rep(0, N), sigma=A)
head(x)
head(X)
theta.star <- rep(1, p)
p <- 100
theta.star <- rep(1, p)
theta.star
rvnorm
?rvnorm
?rvnorm
?rnorm
X <- rmvnorm(N, mean=rep(0, p), sigma=A)
# Generate vector of epsilons
epsilon <- rnorm(N, mean=0, sd=1)
# Compute observations
y <- t(X) %*% theta.star + epsilon
y
T = 1e5
t <- 1
X <- rmvnorm(1, mean=rep(0, p), sigma=A)
X
epsilon <- rnorm(1, mean=0, sd=1)
epsilon
y <- t(x) %*% theta.star + epsilon
x <- rmvnorm(1, mean=rep(0, p), sigma=A)
y <- t(x) %*% theta.star + epsilon
y
dim(y)
x
dim(x)
x <- t(rmvnorm(1, mean=rep(0, p), sigma=A))
# Generate vector of epsilons
epsilon <- rnorm(1, mean=0, sd=1)
# Compute observations
y <- t(x) %*% theta.star + epsilon
y
?trace
?tr
library(matrixcalc)
?matrix.trace
gamma.0 <- 1 / matrix.trace(A)
## Metropolis-Hastings and convergence
## Fall, 2014, Panos Toulis ptoulis@fas.harvard.edu
##
library(mvtnorm)
library(coda)
d = 5  # dimensions
mu.vector <- c(1:d)
rho = 0.5  # autocorrelation between components
Sigma <- (1-rho) * diag(d) + rho * matrix(1, nrow=d, ncol=d)
# We will sample from
# y ~ N(m, S)  where m = (1, 2, 3...d)  and S = r I + (1-r) U  i.e., equicorrelation
NormalMHExample<-function(mcmc.niters, oracle=F) {
# Runs Metropolis-Hastings for the MVN example
# Returns  sims x d  matrix with samples.
#
# Use oracle=T if you need "perfect sampling"
#
# the chain matrix
theta.mh <- matrix(0, nrow = mcmc.niters, ncol = d)
# Start from overdispersed
theta.mh[1, ] <- rmvnorm(n=1, mean=mu.vector, sigma=2 * Sigma)
pb = txtProgressBar(style=3)
nacc <- 0  # count of acceptance
for (i in 2:mcmc.niters) {
# 1. Get current state of the chain
theta.old <- theta.mh[i-1,]  # prev parameters
# 2. Propose new state (theta.new)
if(oracle) {
# Here we sample from the actual distribution.
# We do this to check the effectiveness of the convergence checks.
theta.new <- rmvnorm(n=1, mean=mu.vector, sigma=Sigma)
} else {
# Propose  theta.new ~ N(theta.old, s * I)  i.e., around the current state
theta.new <- rmvnorm(n=1, mean=theta.old, sigma=2 * diag(d))  # new params
}
setTxtProgressBar(pb, value=i/mcmc.niters)
# 3. Compute MH ratio (the terms from the propNoosal cancel out by symmetry)
log.a = min(0, dmvnorm(theta.new, mean=mu.vector, sigma=Sigma, log=T) -
dmvnorm(theta.old, mean=mu.vector, sigma=Sigma, log=T))
# 4. accept-reject
if(runif(1) < exp(log.a)) {
theta.mh[i,] <- theta.new
nacc <- nacc + 1
} else {
theta.mh[i,] <- theta.old
}
}
# 5. (optional) Print some statistics to make sure it is fine.
print(sprintf("Acceptance rate %.2f%%", 100 * nacc/mcmc.niters))
burnin = 0.3 * mcmc.niters
return(theta.mh[-c(1:burnin),])
}
# Run the chain
run.chain <- function(show.diagnostics=F, oracle=F) {
mh.draws <- NormalMHExample(mcmc.niters = 5000, oracle=oracle)
##  Do the diagnostics here.
if (show.diagnostics) {
library(coda)
mcmc.chain <- mcmc(mh.draws)
fns <- c("summary", "plot", "autocorr.plot", "rejectionRate")
for (fn in fns) {
readline(sprintf("Press [ENTER] for %s", fn))
do.call(fn, args=list(mcmc.chain))
}
}
print("Geweke diagnostic")
print(geweke.diag(mh.draws))
print("Raftery diagnostic")
print(raftery.diag(mh.draws, r=0.005))
print("Heidelberg diagnostic")
print(heidel.diag(mh.draws))
}
rubin.gelman <- function(nchains=5) {
mh.list <- list()
print("Calculating Gelman-Rubin diag")
pb = txtProgressBar(style=3)
for(i in 1:nchains) {
mh.list[[i]] <- mcmc(NormalMHExample(mcmc.niters = 2000, oracle = F))
setTxtProgressBar(pb, value=i/nchains)
}
mh.list <- mcmc.list(mh.list)
print(gelman.diag(mh.list))
}
ex <- NormalMHExample(100000)
ex <- NormalMHExample(10000)
?rbeta
?regeom
?rgeom
N.old <- 4
S <- 67
S.exp <- N.old * rbeta(1, 1 + S, 1 + (N.old - S))
S
N.old
# Chain samples S.exp = N * theta, and then N
mcmc.mh <- function(y, mcmc.niters=1e4) {
# Complete with MH.
S = sum(y)
n = length(y)
mcmc.chain <- matrix(0, nrow=mcmc.niters, ncol=2)
mcmc.chain[1, ] <- c(max(y), 0.1)
nacc <- 0
for(i in 2:mcmc.niters) {
# 1. Current state
N.old = mcmc.chain[i-1, 1]
theta.old = mcmc.chain[i-1, 2]
# 2. Propose new state
# Sample S from old N state
S.exp <- N.old * rbeta(1, 1 + S, 1 + (N.old - S))
# Draw N proposal
N.new <- regeom(1, 1 / N.old)
theta.new <- S.exp / N.new
# 3. Ratio
mh.ratio = min(0, log.posterior(N.new, theta.new, y) -
log.posterior(N.old, theta.old, y))
if(N.new > max(y) & runif(1) < exp(mh.ratio)) {
# Accept
mcmc.chain[i, ] <- c(N.new, theta.new)
nacc <- nacc + 1
} else {
mcmc.chain[i, ] <- c(N.old, theta.old)
}
}
# Cut the burnin period.
print(sprintf("Acceptance ratio %.2f%%", 100 * nacc / mcmc.niters))
plot.chain(mcmc.chain)
return(mcmc.chain)
}
setwd("~/Documents/Harvard/Stats/STAT221/HW 4")
imp <- read.table("./dat/impala.txt")[2:6, ]
imp <- as.numeric(levels(imp))[imp]
wat <-  read.table("./dat/waterbuck.txt")[2:6, ]
wat <- as.numeric(levels(wat))[wat]
mcmc.mh(imp)
# Chain samples S.exp = N * theta, and then N
mcmc.mh <- function(y, mcmc.niters=1e4) {
# Complete with MH.
S = sum(y)
n = length(y)
mcmc.chain <- matrix(0, nrow=mcmc.niters, ncol=2)
mcmc.chain[1, ] <- c(max(y), 0.1)
nacc <- 0
for(i in 2:mcmc.niters) {
# 1. Current state
N.old = mcmc.chain[i-1, 1]
theta.old = mcmc.chain[i-1, 2]
# 2. Propose new state
# Sample S from old N state
S.exp <- N.old * rbeta(1, 1 + S, 1 + (N.old - S))
# Draw N proposal
N.new <- rgeom(1, 1 / N.old)
theta.new <- S.exp / N.new
# 3. Ratio
mh.ratio = min(0, log.posterior(N.new, theta.new, y) -
log.posterior(N.old, theta.old, y))
if(N.new > max(y) & runif(1) < exp(mh.ratio)) {
# Accept
mcmc.chain[i, ] <- c(N.new, theta.new)
nacc <- nacc + 1
} else {
mcmc.chain[i, ] <- c(N.old, theta.old)
}
}
# Cut the burnin period.
print(sprintf("Acceptance ratio %.2f%%", 100 * nacc / mcmc.niters))
plot.chain(mcmc.chain)
return(mcmc.chain)
}
mcmc.mh(imp)
S = sum(y)
n = length(y)
mcmc.chain <- matrix(0, nrow=mcmc.niters, ncol=2)
mcmc.chain[1, ] <- c(max(y), 0.1)
nacc <- 0
y <- imp
S = sum(y)
n = length(y)
mcmc.chain <- matrix(0, nrow=mcmc.niters, ncol=2)
mcmc.chain[1, ] <- c(max(y), 0.1)
nacc <- 0
n.iters = 1e4
S = sum(y)
n = length(y)
mcmc.chain <- matrix(0, nrow=mcmc.niters, ncol=2)
mcmc.chain[1, ] <- c(max(y), 0.1)
nacc <- 0
mcmc.niters = 1e4
S = sum(y)
n = length(y)
mcmc.chain <- matrix(0, nrow=mcmc.niters, ncol=2)
mcmc.chain[1, ] <- c(max(y), 0.1)
nacc <- 0
i <-2
N.old = mcmc.chain[i-1, 1]
theta.old = mcmc.chain[i-1, 2]
# 2. Propose new state
# Sample S from old N state
S.exp <- N.old * rbeta(1, 1 + S, 1 + (N.old - S))
N.ol
N.old
S
n * N.old
S
# Chain samples S.exp = N * theta, and then N
mcmc.mh <- function(y, mcmc.niters=1e4) {
# Complete with MH.
S = sum(y)
n = length(y)
mcmc.chain <- matrix(0, nrow=mcmc.niters, ncol=2)
mcmc.chain[1, ] <- c(max(y), 0.1)
nacc <- 0
for(i in 2:mcmc.niters) {
# 1. Current state
N.old = mcmc.chain[i-1, 1]
theta.old = mcmc.chain[i-1, 2]
# 2. Propose new state
# Sample S from old N state
S.exp <- N.old * rbeta(1, 1 + S, 1 + (n * N.old - S))
# Draw N proposal
N.new <- rgeom(1, 1 / N.old)
theta.new <- S.exp / N.new
# 3. Ratio
mh.ratio = min(0, log.posterior(N.new, theta.new, y) -
log.posterior(N.old, theta.old, y))
if(N.new > max(y) & runif(1) < exp(mh.ratio)) {
# Accept
mcmc.chain[i, ] <- c(N.new, theta.new)
nacc <- nacc + 1
} else {
mcmc.chain[i, ] <- c(N.old, theta.old)
}
}
# Cut the burnin period.
print(sprintf("Acceptance ratio %.2f%%", 100 * nacc / mcmc.niters))
plot.chain(mcmc.chain)
return(mcmc.chain)
}
mcmc.mh(y)
log.lik <- function(N, theta, Y) {
# Log-likelihood of the data
sum(dbinom(Y, size=N, prob=theta, log=T))
}
log.prior <- function(N, theta) {
# Induced prior on N, theta
return(log(1 / N))
}
log.posterior <- function(N, theta, Y) {
log.lik(N, theta, Y) + log.prior(N, theta)
}
plot.posterior.density <- function(data) {
# Plots the density of the posterior density with contour lines.
#
# Args:
#   data = vector of values (generated by sample.data)
# Example:
#   y = sample.data(100)
#   explore.posterior.density(y)
N = max(data):(10 * max(data))
theta = seq(1e-5, 1, length.out=100)
gr = expand.grid(x=N, y=theta)
z = apply(gr, 1, function(par) log.lik(par[1], par[2], data))
z = matrix(z, nrow=length(N), ncol=length(theta))
print("Summay of likelihood values.")
print(summary(as.vector(z)))
#print("log-likelihood of the true parameter values")
#print(log.lik(kAlpha, kBeta, data))
z0 = quantile(z, probs = c(0.1))
z1 = max(z)
ncols = 10000
cols = topo.colors(ncols)
i = apply(gr, 1, function(par) {
ll = log.posterior(par[1], par[2], data)
if(ll < z0) return(0)
return((ll - z0) / (z1 - z0))
})
par(mfrow=c(1, 1))
# hist(i)
j = ncols * i
j[j==0] <- 1
plot(gr[,1], gr[,2], xlab="N", ylab="theta", col=cols[j], pch=".", cex=4)
contour(N, theta, z, nlevels = 50, add=T, cex=2, col="black")
#points(c(kAlpha), c(kBeta), pch="x", cex=2.5)
#lines(a, kAlpha * kBeta / a, col="red")
}
plot.chain <- function(mcmc.chain) {
mcmc.niters = nrow(mcmc.chain)
burnin = 0.1 * mcmc.niters
mcmc.chain = mcmc.chain[burnin:mcmc.niters, ]
f = kde2d(x=mcmc.chain[, 1], y=mcmc.chain[, 2], n=100)
image(f, xlim=c(0, 100), ylim=c(0, 1))
}
mcmc.mh(y)
library(MASS)
mcmc.mh(y)
chain <- mcmc.mh(y)
summary(chain)
?geom
?rgeom
rgeom.trunc <- function(upper.bound, p) {
# Sample from truncated geom
x <- upper.bound + 10
while(x > upper.bound) {
x = rgeom(1, p)
}
return(x)
}
# Chain samples S.exp = N * theta, and then N
mcmc.mh <- function(y, mcmc.niters=1e4) {
# Complete with MH.
S = sum(y)
n = length(y)
mcmc.chain <- matrix(0, nrow=mcmc.niters, ncol=2)
mcmc.chain[1, ] <- c(max(y), 0.1)
nacc <- 0
for(i in 2:mcmc.niters) {
# 1. Current state
N.old = mcmc.chain[i-1, 1]
theta.old = mcmc.chain[i-1, 2]
# 2. Propose new state
# Sample S from old N state
S.exp <- N.old * rbeta(1, 1 + S, 1 + (n * N.old - S))
# Draw N proposal
N.new <- rgeom.trunc(max(y), 1 / N.old)
theta.new <- S.exp / N.new
# 3. Ratio
mh.ratio = min(0, log.posterior(N.new, theta.new, y) -
log.posterior(N.old, theta.old, y))
if(runif(1) < exp(mh.ratio)) {
# Accept
mcmc.chain[i, ] <- c(N.new, theta.new)
nacc <- nacc + 1
} else {
mcmc.chain[i, ] <- c(N.old, theta.old)
}
}
# Cut the burnin period.
print(sprintf("Acceptance ratio %.2f%%", 100 * nacc / mcmc.niters))
plot.chain(mcmc.chain)
return(mcmc.chain)
}
chain <- mcmc.mh(y)
rgeom.trunc <- function(lower.bound, p) {
# Sample from truncated geom
x <- lower.bound - 1
while(x < upper.bound) {
x = rgeom(1, p)
}
return(x)
}
# Chain samples S.exp = N * theta, and then N
mcmc.mh <- function(y, mcmc.niters=1e4) {
# Complete with MH.
S = sum(y)
n = length(y)
mcmc.chain <- matrix(0, nrow=mcmc.niters, ncol=2)
mcmc.chain[1, ] <- c(max(y), 0.1)
nacc <- 0
for(i in 2:mcmc.niters) {
# 1. Current state
N.old = mcmc.chain[i-1, 1]
theta.old = mcmc.chain[i-1, 2]
# 2. Propose new state
# Sample S from old N state
S.exp <- N.old * rbeta(1, 1 + S, 1 + (n * N.old - S))
# Draw N proposal
N.new <- rgeom.trunc(max(y), 1 / N.old)
theta.new <- S.exp / N.new
# 3. Ratio
mh.ratio = min(0, log.posterior(N.new, theta.new, y) -
log.posterior(N.old, theta.old, y))
if(runif(1) < exp(mh.ratio)) {
# Accept
mcmc.chain[i, ] <- c(N.new, theta.new)
nacc <- nacc + 1
} else {
mcmc.chain[i, ] <- c(N.old, theta.old)
}
}
# Cut the burnin period.
print(sprintf("Acceptance ratio %.2f%%", 100 * nacc / mcmc.niters))
plot.chain(mcmc.chain)
return(mcmc.chain)
}
chain <- mcmc.mh(y)
rgeom.trunc <- function(lower.bound, p) {
# Sample from truncated geom
x <- lower.bound - 1
while(x < lower.bound) {
x = rgeom(1, p)
}
return(x)
}
chain <- mcmc.mh(y)
summary(chain)
chain <- mcmc.mh(y)
summary(chain)
chain <- mcmc.mh(y)
chain <- mcmc.mh(y)
summary(chain)
chain <- mcmc.mh(wat)
sumarry(chain)
summary(chain)
rubin.gelman(chain)
summary(chain)
mcmc.diagnosis <- function(chain) {
library(coda)
mcmc.chain <- mcmc(chain)
fns <- c("summary", "plot", "autocorr.plot", "rejectionRate")
for (fn in fns) {
readline(sprintf("Press [ENTER] for %s", fn))
do.call(fn, args=list(mcmc.chain))
}
print("Geweke diagnostic")
print(geweke.diag(mh.draws))
print("Raftery diagnostic")
print(raftery.diag(mh.draws, r=0.005))
print("Heidelberg diagnostic")
print(heidel.diag(mh.draws))
}
mcmc.diagnosis(chain)
install.packages('coda')
## Diagnosis functions for the chain
mcmc.diagnosis <- function(chain) {
mcmc.chain <- mcmc(chain)
fns <- c("summary", "plot", "autocorr.plot", "rejectionRate")
for (fn in fns) {
readline(sprintf("Press [ENTER] for %s", fn))
do.call(fn, args=list(mcmc.chain))
}
print("Geweke diagnostic")
print(geweke.diag(mh.draws))
print("Raftery diagnostic")
print(raftery.diag(mh.draws, r=0.005))
print("Heidelberg diagnostic")
print(heidel.diag(mh.draws))
}
install.packages('coda')
mcmc.diagnosis(chain)
library(coda)
?mcmc
mcmc.diagnosis(chain)
## Diagnosis functions for the chain
mcmc.diagnosis <- function(chain) {
mcmc.chain <- mcmc(chain)
fns <- c("summary", "plot", "autocorr.plot", "rejectionRate")
for (fn in fns) {
readline(sprintf("Press [ENTER] for %s", fn))
do.call(fn, args=list(mcmc.chain))
}
print("Geweke diagnostic")
print(geweke.diag(chain))
print("Raftery diagnostic")
print(raftery.diag(chain, r=0.005))
print("Heidelberg diagnostic")
print(heidel.diag(chain))
}
mcmc.diagnosis(chain)
