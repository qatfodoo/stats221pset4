# MCMC algorithm for Raftery replication.
# Adapts the structure of Panos' code.

#
# y ~ Pois(N, theta), N theta unknown
#
rm(list=ls())
library(MASS)
library(coda)
lambdaBound = 100

log.lik <- function(N, theta, Y) {
  # Log-likelihood of the data
  sum(dbinom(Y, size=N, prob=theta, log=T))
}

log.prior <- function(N, theta) {
  # Induced prior on N, theta
  return(log(1 / N))
}

log.posterior <- function(N, theta, Y) {
  log.lik(N, theta, Y) + log.prior(N, theta)
}

plot.posterior.density <- function(data) {
  # Plots the density of the posterior density with contour lines.
  #
  # Args:
  #   data = vector of values (generated by sample.data)
  # Example:
  #   y = sample.data(100)
  #   explore.posterior.density(y)
  N = max(data):(10 * max(data))
  theta = seq(1e-5, 1, length.out=100)
  gr = expand.grid(x=N, y=theta)
  z = apply(gr, 1, function(par) log.lik(par[1], par[2], data))
  z = matrix(z, nrow=length(N), ncol=length(theta))
  print("Summay of likelihood values.")
  print(summary(as.vector(z)))
  #print("log-likelihood of the true parameter values")
  #print(log.lik(kAlpha, kBeta, data))
  z0 = quantile(z, probs = c(0.1))
  z1 = max(z)
  ncols = 10000
  cols = topo.colors(ncols)
  i = apply(gr, 1, function(par) {
    ll = log.posterior(par[1], par[2], data)
    if(ll < z0) return(0)
    return((ll - z0) / (z1 - z0))
  })
  par(mfrow=c(1, 1))
  # hist(i)
  j = ncols * i
  j[j==0] <- 1
  plot(gr[,1], gr[,2], xlab="N", ylab="theta", col=cols[j], pch=".", cex=4)
  contour(N, theta, z, nlevels = 50, add=T, cex=2, col="black")
  #points(c(kAlpha), c(kBeta), pch="x", cex=2.5)
  #lines(a, kAlpha * kBeta / a, col="red")
}

rgeom.trunc <- function(lower.bound, p) {
  # Sample from truncated geom 
  x <- lower.bound - 1
  while(x < lower.bound) {
    x = rgeom(1, p)
  }
  return(x)
}

rgamma.trunc <- function(lower.bound, s, r) {
  # Sample from truncated gamma. 
  x <- lower.bound - 1
  while(x < lower.bound) {
    x = rgamma(1, shape=s, rate=r)
  }
  return(x)
}


plot.chain <- function(mcmc.chain, max_x=100) {
  mcmc.niters = nrow(mcmc.chain)
  burnin = 0.1 * mcmc.niters
  mcmc.chain = mcmc.chain[burnin:mcmc.niters, ]
  x <- mcmc.chain[, 1]
  y <- mcmc.chain[, 2]
  f = kde2d(x=x, y=y, n=c(max(x) - min(x), 200))
  image(f, xlim=c(min(x), max_x), ylim=c(0, 1))
}

mcmc.gibbs <- function(y, mcmc.niters=1e4) {
  # Runs Gibbs on the data y
  S = sum(y)  # sufficient statistic
  n = length(y)
  
  mcmc.chain <- matrix(3, nrow=mcmc.niters, ncol=2)
  
  for(i in 2:mcmc.niters) {
    beta.last <- mcmc.chain[i-1, 2]
    # Conditionals are truncated gammas.
    alpha <- rgamma.trunc(kBound, s=S+1, r=n * beta.last)
    beta <- rgamma.trunc(kBound, s=S+1,  r=n * alpha)
    mcmc.chain[i, ] <- c(alpha, beta)
  }
  # Plot empirical density
  plot.chain(mcmc.chain)
  return(mcmc.chain)
}


# Chain samples from uniform theta and N (range of 20 around N.old)
mcmc.mhdir <- function(y, mcmc.niters=1e4, max_x=100) {
  # Complete with MH.
  S = sum(y)
  n = length(y)
  mcmc.chain <- matrix(0, nrow=mcmc.niters, ncol=2)
  mcmc.chain[1, ] <- c(max(y), 0.1)
  nacc <- 0
  for(i in 2:mcmc.niters) {
    # 1. Current state
    N.old = mcmc.chain[i-1, 1]
    theta.old = mcmc.chain[i-1, 2]
    # 2. Propose new state
    # Draw N proposal
    #N.new <- sample(max(max(y), (N.old - 5)):(max(max(y) + 5, N.old + 5)), 1)
    N.new <- rgeom.trunc(max(y), 1 / N.old)
    #theta.new <- runif(1, min=0, max=1)
    theta.new <- rbeta(1, 1 + S, 1 + (n * N.old - S))
    # 3. Ratio
    
    mh.ratio = min(0, log.posterior(N.new, theta.new, y) - #+ dgeom(N.old, 1 / N.new, log=T) + 
                     #dbeta(theta.old, 1 + S, 1 + (n * N.new - S), log=T) -
                     log.posterior(N.old, theta.old, y)) #- dgeom(N.new, 1 / N.old, log=T) -
                     #dbeta(theta.new, 1 + S, 1 + (n * N.old - S), log=T))
    
#     mh.ratio = min(0, log.posterior(N.new, theta.new, y) + log(ProbUnifN(max(y), N.new)) - 
#                      log.posterior(N.old, theta.old, y) - log(ProbUnifN(max(y), N.old)))
    
    if(runif(1) < exp(mh.ratio)) {
      # Accept 
      mcmc.chain[i, ] <- c(N.new, theta.new)
      nacc <- nacc + 1
    } else {
      mcmc.chain[i, ] <- c(N.old, theta.old)
    }
  }
  # Cut the burnin period.
  print(sprintf("Acceptance ratio %.2f%%", 100 * nacc / mcmc.niters))
  plot.chain(mcmc.chain, max_x)
  return(mcmc.chain)
}

# Compute probab of the truncated uniform centered at N
ProbUnifN <- function(y.max, N) {
  n.poss <- 5 + N - max(y.max, N - 5) + 1  # numb of potential samples
  return(1 / n.poss)
}


# Chain samples S.exp = N * theta, and then N
## But ignores non-symmetry of proposal
mcmc.mh_Sexplogonly <- function(y, mcmc.niters=1e4, max_x=100) {
  # Complete with MH.
  S = sum(y)
  n = length(y)
  mcmc.chain <- matrix(0, nrow=mcmc.niters, ncol=2)
  mcmc.chain[1, ] <- c(max(y), 0.1)
  nacc <- 0
  for(i in 2:mcmc.niters) {
    # 1. Current state
    N.old = mcmc.chain[i-1, 1]
    theta.old = mcmc.chain[i-1, 2]
    # 2. Propose new state
    # Sample S from old N state
    S.exp <- N.old * rbeta(1, 1 + S, 1 + (n * N.old - S))
    # Draw N proposal
    N.new <- rgeom.trunc(max(y), 1 / (N.old + 1))
    theta.new <- S.exp / N.new
    # 3. Ratio
    
    mh.ratio = min(0, log.posterior(N.new, theta.new, y) -
                     log.posterior(N.old, theta.old, y))
    
    if(is.finite(mh.ratio) & runif(1) < exp(mh.ratio)) {
      # Accept 
      mcmc.chain[i, ] <- c(N.new, theta.new)
      nacc <- nacc + 1
    } else {
      mcmc.chain[i, ] <- c(N.old, theta.old)
    }
  }
  # Cut the burnin period.
  print(sprintf("Acceptance ratio %.2f%%", 100 * nacc / mcmc.niters))
  plot.chain(mcmc.chain, max_x)
  return(mcmc.chain)
}

# Chain samples S.exp = N * theta, and then N
## Explodes towards large N for unknown reasons
mcmc.mh_Sexp <- function(y, mcmc.niters=1e4, max_x=100) {
  # Complete with MH.
  S = sum(y)
  n = length(y)
  mcmc.chain <- matrix(0, nrow=mcmc.niters, ncol=2)
  mcmc.chain[1, ] <- c(max(y), 0.1)
  nacc <- 0
  for(i in 2:mcmc.niters) {
    # 1. Current state
    N.old = mcmc.chain[i-1, 1]
    theta.old = mcmc.chain[i-1, 2]
    # 2. Propose new state
    # Sample S from old N state
    S.exp <- N.old * rbeta(1, 1 + S, 1 + (n * N.old - S))
    # Draw N proposal
    N.new <- rgeom.trunc(max(y), 1 / (N.old + 1))
    theta.new <- S.exp / N.new
    # 3. Ratio
    
    mh.ratio = min(0, log.posterior(N.new, theta.new, y) + dgeom(N.old, 1 / N.new, log=T) +
                     dbeta((N.old * theta.old) / N.new, 1 + S, 1 + (n * N.new - S), log=T) - 
                     log.posterior(N.old, theta.old, y) - dgeom(N.new, 1 / N.old, log=T) -
                     dbeta((N.new * theta.new) / N.old, 1 + S, 1 + (n * N.old - S), log=T))

    if(is.finite(mh.ratio) & runif(1) < exp(mh.ratio)) {
      # Accept 
      mcmc.chain[i, ] <- c(N.new, theta.new)
      nacc <- nacc + 1
    } else {
      mcmc.chain[i, ] <- c(N.old, theta.old)
    }
  }
  # Cut the burnin period.
  print(sprintf("Acceptance ratio %.2f%%", 100 * nacc / mcmc.niters))
  plot.chain(mcmc.chain, max_x)
  return(mcmc.chain)
}

# Chain samples first mu and theta, and then N
mcmc.mh2step <- function(y, mcmc.niters=1e4, max_x=100) {
  # Complete with MH.
  S = sum(y)
  n = length(y)
  mcmc.chain <- matrix(0, nrow=mcmc.niters, ncol=2)
  mcmc.chain[1, ] <- c(max(y), 0.1)
  nacc <- 0
  for(i in 2:mcmc.niters) {
    lambda <- rgamma(1, shape=S, rate=n) # Posterior for lambda
    # 1. Current state
    N.old = mcmc.chain[i-1, 1]
    theta.old = mcmc.chain[i-1, 2]
    # 2. Propose new state
    theta.new = rbeta(1, 1 + S, 1 + (n * N.old - S))
    mu.new = lambda / theta.new
    # Draw N proposal
    N.new <- rpois(1, mu.new)
    # 3. Ratio
    mh.ratio = min(0, log.posterior(N.new, theta.new, y) + dbeta(theta.old, 1 + S, 1 + (n * N.new - S), log=T) - 
                     log.posterior(N.old, theta.old, y) - dbeta(theta.new, 1 + S, 1 + (n * N.old - S), log=T))
    # P(N | theta) is the ssymmetric for old and new (lambda has same sampler)
    if(N.new > max(y) & runif(1) < exp(mh.ratio)) {
      # Accept 
      mcmc.chain[i, ] <- c(N.new, theta.new)
      nacc <- nacc + 1
    } else {
      mcmc.chain[i, ] <- c(N.old, theta.old)
    }
  }
  # Cut the burnin period.
  print(sprintf("Acceptance ratio %.2f%%", 100 * nacc / mcmc.niters))
  plot.chain(mcmc.chain, max_x)
  return(mcmc.chain)
}

## Diagnosis functions for the chain
mcmc.diagnosis <- function(chain) {
  
  mcmc.chain <- mcmc(chain)
  fns <- c("summary", "plot", "autocorr.plot", "rejectionRate")
  for (fn in fns) {
    readline(sprintf("Press [ENTER] for %s", fn))
    do.call(fn, args=list(mcmc.chain))
  }
  print("Geweke diagnostic")
  print(geweke.diag(chain))
  
  print("Raftery diagnostic")
  print(raftery.diag(chain, r=0.005))
  
  print("Heidelberg diagnostic")
  print(heidel.diag(chain))

}

## Rubin gelman on chain method
rubin.gelman <- function(y, mcmc.mh, nchains=5) {
  mh.list <- list()
  print("Calculating Gelman-Rubin diag")
  pb = txtProgressBar(style=3)
  for(i in 1:nchains) {
    mh.list[[i]] <- mcmc(mcmc.mh(y, mcmc.niters = 2000))
    setTxtProgressBar(pb, value=i/nchains)
  }
  mh.list <- mcmc.list(mh.list)
  print(gelman.diag(mh.list))
}